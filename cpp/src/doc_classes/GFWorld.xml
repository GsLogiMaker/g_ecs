<?xml version="1.0" encoding="UTF-8" ?>
<class name="GFWorld" inherits="Object"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		An entity component system world.
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="coerce_id">
			<return type="int" />
			<param index="0" name="entity" type="Variant" />
			<description>
				Coerces a [Variant] to an ID.
				How Variants are coerced to IDs goes as follows: [br]- [int] : Used as ID directly. [br]- [String] : Treated as a path and looks up the entity at that path. [br]- [StringName] : Treated as a path and looks up the entity at that path. [br]- [NodePath] : Treated as a path and looks up the entity at that path. [br]- [Vector2i] : Used directly as a relationship pair. [br]- [GFEntity] (and subtypes) : Returns the ID of the entity being referenced.[br]- [Script] : If the script extends [GFRegisterableEntity] and is registered with the [GFWorld], then returns the associated ID.[br]- Everything else : Returns [code]0[/code] and pushes an error.
				This example shows a coercion from an [int]:
				[codeblock]
				var world:= GFWorld.new()
				world.coerce_id(25) == 25 # true
				[/codeblock]
				This example shows a coercion from a [String] as a path:
				[codeblock]
				var world:= GFWorld.new()
				world.coerce_id("flecs/core/Component") == 1 # true
				[/codeblock]
				This example shows a coercion from a [GFEntity]:
				[codeblock]
				var world:= GFWorld.new()
				var entity:= GFEntity.from(255, world)
				world.coerce_id(entity) == 255 # true
				[/codeblock]
				This example shows a coercion from a [Vector2i]:
				[codeblock]
				var world:= GFWorld.new()
				var Eats:= GFEntity.new_in_world(world)
				var Carrots:= GFEntity.new_in_world(world)
				var pair:= Vector2i(Eats.get_id(), Carrots.get_id())
				world.coerce_id(pair) == world.pair(Eats, Carrots) # true
				[/codeblock]
				This example shows a coercion from a registered [Script]:
				[codeblock]
				class Health extends GFComponent:
				    func _build(b:GFComponentBuilder) -&gt; void:
				        b.add_member("health", TYPE_FLOAT)

				var world:= GFWorld.new()
				func _init() -&gt; void:
				    world.register_script(Health)
				    world.coerce_id(Health) # The ID of the Health component
				[/codeblock]
			</description>
		</method>
		<method name="get_default_world" qualifiers="static">
			<return type="GFWorld" />
			<description>
				Returns the current default world. If no default world is set then this method will return the world from [method get_singleton]. See [method set_default_world] for more information on default worlds.
				[b]NOTE:[/b] Default worlds are unique per thread. This method will only return worlds set in the same thread.
			</description>
		</method>
		<method name="get_raw" qualifiers="const">
			<return type="int" />
			<description>
				Returns the raw pointer to the underlying Flecs world ([code]ecs_world_t *[/code]).
				Below is an example of how to use this method in a C++ [GDExtension]:
				[codeblock lang=cpp]
				Object *gf_world = ...;
				uint64_t raw_i = gf_world-&gt;call("get_raw");
				ecs_world_t *raw = reinterpret_cast&lt;ecs_world_t*&gt;(raw_i);

				ecs_new(raw); // Create a new entity
				[/codeblock]
				[b]WARNING:[/b] Do not call finish, or otherwise destruct the [code]ecs_world_t[/code]. The world object is managed by [GFWorld] and freeing it separate from the [GFWorld] will cause undefined behavior or crashes.
			</description>
		</method>
		<method name="get_singleton" qualifiers="static">
			<return type="GFWorld" />
			<description>
				Returns the global world of the program.
				Example:
				[codeblock]
				var world = GFWorld.get_singleton()
				GFEntity.new_in_world(world)
				[/codeblock]
			</description>
		</method>
		<method name="lookup">
			<return type="GFEntity" />
			<param index="0" name="path" type="String" />
			<description>
				Finds and returns an entity according to its path.
				[codeblock]
				GFGlobalWorld.lookup("glecs/meta/Vector2")
				[/codeblock]
			</description>
		</method>
		<method name="pair">
			<return type="GFPair" />
			<param index="0" name="first" type="Variant" />
			<param index="1" name="second" type="Variant" />
			<description>
				Creates and returns a pair from two [Variant]s coerced to IDs.
				To learn more about [Variant] coercion see [method GFWorld.coerce_id].
				[codeblock]
				var world:= GFWorld.new()
				var Attacks_tag:= GFEntity.new_in_world(world)
				var Players_tag:= GFEntity.new_in_world(world)
				world.pair(Attacks_tag, Players_tag)
				[/codeblock]
			</description>
		</method>
		<method name="pair_ids" qualifiers="const">
			<return type="int" />
			<param index="0" name="first" type="int" />
			<param index="1" name="second" type="int" />
			<description>
				Creates and returns a pair ID from two IDs.
				[codeblock]
				var world:= GFWorld.new()
				var Attacks_tag:= GFEntity.new_in_world(world)
				var Player_tag:= GFEntity.new_in_world(world)
				world.pair_ids(Attacks_tag.get_id(), Player_tag.get_id())
				[/codeblock]
			</description>
		</method>
		<method name="progress" qualifiers="const">
			<return type="void" />
			<param index="0" name="delta" type="float" />
			<description>
				Progresses the world by the supplied amount of time.
				[codeblock]
				extends Node

				var world:= GFWorld.new()

				func _process(delta:float) -&gt; void:
				    world.progress(delta)
				[/codeblock]
			</description>
		</method>
		<method name="register_script">
			<return type="GFRegisterableEntity" />
			<param index="0" name="script" type="Script" />
			<description>
				Registers a [Script] that derives from [GFRegisterableEntity].
				A [Script], once registered, gets an entity ID created and associated with it. This allows the [Script] to be coerced to the associated ID. To learn more about [Variant] coercion see [method GFWorld.coerce_id].
				This example shows registering the [i]Health[/i] [Script] as a component.
				[codeblock]
				class Health extends GFComponent:
				    func _build(b:GFComponentBuilder) -&gt; void:
				        b.add_member("health", TYPE_FLOAT)

				var world:= GFWorld.new()
				func _init() -&gt; void:
				    world.register_script(Health)
				    world.coerce_id(Health) # The ID of the Health component
				[/codeblock]
			</description>
		</method>
		<method name="set_default_world" qualifiers="static">
			<return type="void" />
			<param index="0" name="world" type="GFWorld" />
			<description>
				Sets the default world that methods like [method GFEntity.new] use to determine which world to create objects in.
				This method can be used as a means of switching the context (world) in which ECS operations take place. For example:
				[codeblock]
					var custom_default_world = GFWorld.new()

					var old_default_world = GFWorld.get_default_world()
					GFWorld.set_default_world(custom_default_world)

					# The following line creates an entity in
					# `custom_default_world` when it otherwise
					# would've been created in `old_default_world`.
					var entity = GFEntity.new()

					# It is a good practice to restore the default
					# world to whatever it was before you set it.
					GFWorld.set_default_world(old_default_world)
				[/codeblock]
				Changing the default world can be used as an alternative to [code]new_in_world[/code] methods such as [method GFSystemBuilder.new_in_world]. This method is called internally before [method GFRegisterableEntity._register] is called so that entities created during registration are created in the same world as the registered entity. This is particularly helpful when registering [GFModule]s where you may be creating many entities, systems, and observers. If [method set_default_world] wasn't called before registering modules then you would need to use [code]new_in_world[/code] methods instead of [code]new[/code] if you wanted your module to work in worlds other than the global returned from [method get_singleton].
				[b]NOTE:[/b] Default worlds are unique per thread. This method will only affect the thread it was called in.
			</description>
		</method>
		<method name="start_rest_api" qualifiers="const">
			<return type="void" />
			<description>
				Starts the REST API server.
				The REST API can be used to interface the world from other running processes or other devices. It also exposes the world to the Flecs inspector. This example shows the minimum setup to expose your world to the Flecs inspector:
				[codeblock]
				extends Node

				var world:= GFWorld.new()

				func _ready() -&gt; void:
				    world.start_rest_api()

				func _process(delta:float) -&gt; void:
				    world.progress(delta)
				[/codeblock]
			</description>
		</method>
	</methods>
</class>
