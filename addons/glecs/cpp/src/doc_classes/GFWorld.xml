<?xml version="1.0" encoding="UTF-8" ?>
<class name="GFWorld" inherits="Object" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		An entity component system world.
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="coerce_id">
			<return type="int" />
			<param index="0" name="entity" type="Variant" />
			<description>
				Coerces a [Variant] to an ID.
				How Variants are coerced to IDs goes as follows: [br]- [int] : Used as ID directly. [br]- [String] : Treated as a path and looks up the entity at that path. [br]- [StringName] : Treated as a path and looks up the entity at that path. [br]- [NodePath] : Treated as a path and looks up the entity at that path. [br]- [Vector2i] : Used directly as a relationship pair. [br]- [GFEntity] (and subtypes) : Returns the ID of the entity being referenced.[br]- [Script] : If the script extends [GFRegisterableEntity] and is registered with the [GFWorld], then returns the associated ID.[br]- Everything else : Returns [code]0[/code] and pushes an error.
				This example shows a coercion from an [int]:
				[codeblock]
				var world:= GFWorld.new()
				world.coerce_id(25) == 25 # true
				[/codeblock]
				This example shows a coercion from a [String] as a path:
				[codeblock]
				var world:= GFWorld.new()
				world.coerce_id("flecs/core/Component") == 1 # true
				[/codeblock]
				This example shows a coercion from a [GFEntity]:
				[codeblock]
				var world:= GFWorld.new()
				var entity:= GFEntity.from(255, world)
				world.coerce_id(entity) == 255 # true
				[/codeblock]
				This example shows a coercion from a [Vector2i]:
				[codeblock]
				var world:= GFWorld.new()
				var Eats:= GFEntity.spawn(world)
				var Carrots:= GFEntity.spawn(world)
				var pair:= Vector2i(Eats.get_id(), Carrots.get_id())
				world.coerce_id(pair) == world.pair(Eats, Carrots) # true
				[/codeblock]
				This example shows a coercion from a registered [Script]:
				[codeblock]
				class Health extends GFComponent:
				    func _build(b:GFComponentBuilder) -&gt; void:
				        b.add_member("health", TYPE_FLOAT)

				var world:= GFWorld.new()
				func _init() -&gt; void:
				    world.register_script(Health)
				    world.coerce_id(Health) # The ID of the Health component
				[/codeblock]
			</description>
		</method>
		<method name="component_builder">
			<return type="GFComponentBuilder" />
			<description>
				Returns a new component builder.
				This example shows the creation of a [i]Jump[/i] component:
				[codeblock]
				var world:= GFWorld.new()
				world.component_builder() \
				    .set_name("Jump") \
				    .add_member("jump_velocity", TYPE_FLOAT) \
				    .build()
				[/codeblock]
			</description>
		</method>
		<method name="observer_builder" qualifiers="const vararg">
			<return type="GFObserverBuilder" />
			<description>
				Returns a new observer builder.
				Arguments to this method specify the events (coerced from IDs) that this observer listens for. To learn more about [Variant] coercion see [method GFWorld.coerce_id].
				This example shows the creation of an observer that is run whenever the [i]Jump[/i] component is added to an entity:
				[codeblock]
				var world:= GFWorld.new()
				world.observer_builder("flecs/core/OnAdd") \
				    .with("Jump") \
				    .for_each(func(jump:GFComponent):
				        pass
				        )
				[/codeblock]
			</description>
		</method>
		<method name="pair">
			<return type="GFPair" />
			<param index="0" name="first" type="Variant" />
			<param index="1" name="second" type="Variant" />
			<description>
				Creates and returns a pair from two [Variant]s coerced to IDs.
				To learn more about [Variant] coercion see [method GFWorld.coerce_id].
				[codeblock]
				var world:= GFWorld.new()
				var Attacks_tag:= GFEntity.spawn()
				var Players_tag:= GFEntity.spawn()
				world.pair(Attacks_tag, Players_tag)
				[/codeblock]
			</description>
		</method>
		<method name="pair_ids">
			<return type="int" />
			<param index="0" name="first" type="int" />
			<param index="1" name="second" type="int" />
			<description>
				Creates and returns a pair ID from two IDs.
				[codeblock]
				var world:= GFWorld.new()
				var Attacks_tag:= GFEntity.spawn()
				var Player_tag:= GFEntity.spawn()
				world.pair_ids(Attacks_tag.get_id(), Player_tag.get_id())
				[/codeblock]
			</description>
		</method>
		<method name="progress">
			<return type="void" />
			<param index="0" name="delta" type="float" />
			<description>
				Progresses the world by the supplied amount of time.
				[codeblock]
				extends Node

				var world:= GFWorld.new()

				func _process(delta:float) -&gt; void:
				    world.progress(delta)
				[/codeblock]
			</description>
		</method>
		<method name="query_builder">
			<return type="GFQueryBuilder" />
			<description>
				Returns a new query builder.
				This example shows the creation of a query for entities with the [i]Jump[/i] component:
				[codeblock]
				var world:= GFWorld.new()
				world.query_builder() \
				    .with("Jump") \
				    .build()
				[/codeblock]
			</description>
		</method>
		<method name="register_script">
			<return type="void" />
			<param index="0" name="script" type="Script" />
			<description>
				Registers a [Script] that derives from [GFRegisterableEntity].
				A [Script], once registered, gets an entity ID created and associated with it. This allows the [Script] to be coerced to the associated ID. To learn more about [Variant] coercion see [method GFWorld.coerce_id].
				This example shows registering the [i]Health[/i] [Script] as a component.
				[codeblock]
				class Health extends GFComponent:
				    func _build(b:GFComponentBuilder) -&gt; void:
				        b.add_member("health", TYPE_FLOAT)

				var world:= GFWorld.new()
				func _init() -&gt; void:
				    world.register_script(Health)
				    world.coerce_id(Health) # The ID of the Health component
				[/codeblock]
			</description>
		</method>
		<method name="start_rest_api">
			<return type="void" />
			<description>
				Starts the REST API server.
				The REST API can be used to interface the world from other running processes or other devices. It also exposes the world to the Flecs inspector. This example shows the minimum setup to expose your world to the Flecs inspector:
				[codeblock]
				extends Node

				var world:= GFWorld.new()

				func _ready() -&gt; void:
				    world.start_rest_api()

				func _process(delta:float) -&gt; void:
				    world.progress(delta)
				[/codeblock]
			</description>
		</method>
		<method name="system_builder">
			<return type="GFSystemBuilder" />
			<description>
				Returns a new system builder.
				This example shows the creation of a system that runs for entities with the [i]Jump[/i] component:
				[codeblock]
				var world:= GFWorld.new()
				world.observer_builder() \
				    .with("Jump") \
				    .for_each(func(jump:GFComponent):
				        pass
				        )
				[/codeblock]
			</description>
		</method>
	</methods>
</class>
